/**
 * Google Apps Script Template for Sheets to API Converter
 * 
 * This template is auto-generated by the Sheets to API Chrome Extension
 * It converts a Google Sheet into a REST API endpoint
 * 
 * Variables to be replaced:
 * - {{SPREADSHEET_ID}} - The ID of the target spreadsheet
 * - {{SHEET_NAME}} - The name of the sheet tab to convert
 * - {{INCLUDE_FILTERS}} - Boolean flag for query parameter filtering
 * - {{SPREADSHEET_TITLE}} - Human-readable title of the spreadsheet
 * - {{API_DESCRIPTION}} - Description of the API
 */

// Configuration (will be replaced by the extension)
var CONFIG = {
  SPREADSHEET_ID: '{{SPREADSHEET_ID}}',
  SHEET_NAME: '{{SHEET_NAME}}',
  INCLUDE_FILTERS: '{{INCLUDE_FILTERS}}',
  SPREADSHEET_TITLE: '{{SPREADSHEET_TITLE}}',
  API_DESCRIPTION: '{{API_DESCRIPTION}}',
  GENERATED_BY: 'Sheets to API Chrome Extension',
  VERSION: '1.0.0'
};

/**
 * Main GET handler - Returns sheet data as JSON
 * Supports query parameters for filtering and pagination
 * 
 * @param {Object} e - Event object containing parameters
 * @returns {TextOutput} JSON response
 */
function doGet(e) {
  try {
    Logger.log('API Request received with parameters:', e.parameter);
    
    const sheet = getTargetSheet();
    if (!sheet) {
      return createErrorResponse('Sheet not found: ' + CONFIG.SHEET_NAME, 404);
    }

    const rawData = sheet.getDataRange().getValues();
    
    if (rawData.length === 0) {
      return createSuccessResponse([], {
        message: 'Sheet is empty',
        count: 0
      });
    }

    const headers = rawData[0];
    const rows = rawData.slice(1);
    
    let data = transformRowsToObjects(headers, rows);
    
    // Apply filters if enabled and parameters provided
    if (CONFIG.INCLUDE_FILTERS === 'true' && e.parameter) {
      data = applyFilters(data, e.parameter);
    }
    
    // Apply pagination
    const paginationResult = applyPagination(data, e.parameter);
    
    const response = {
      data: paginationResult.data,
      count: paginationResult.data.length,
      total: paginationResult.total,
      sheet: CONFIG.SHEET_NAME,
      spreadsheet: CONFIG.SPREADSHEET_TITLE,
      timestamp: new Date().toISOString(),
      headers: headers,
      api: {
        version: CONFIG.VERSION,
        generatedBy: CONFIG.GENERATED_BY
      }
    };

    // Add pagination info if applicable
    if (paginationResult.pagination) {
      response.pagination = paginationResult.pagination;
    }

    Logger.log('API Response prepared:', { 
      count: response.count, 
      total: response.total 
    });

    return createSuccessResponse(response.data, response);

  } catch (error) {
    Logger.log('API Error:', error.toString());
    return createErrorResponse('Internal server error: ' + error.toString(), 500);
  }
}

/**
 * POST handler - Health check and API information
 * 
 * @param {Object} e - Event object
 * @returns {TextOutput} JSON response with API status
 */
function doPost(e) {
  const info = {
    status: 'ok',
    message: 'API is running',
    sheet: CONFIG.SHEET_NAME,
    spreadsheet: CONFIG.SPREADSHEET_TITLE,
    methods: ['GET'],
    features: {
      filtering: CONFIG.INCLUDE_FILTERS === 'true',
      pagination: true,
      metadata: true
    },
    endpoints: {
      data: 'GET /',
      health: 'POST /'
    },
    api: {
      version: CONFIG.VERSION,
      generatedBy: CONFIG.GENERATED_BY
    },
    timestamp: new Date().toISOString()
  };

  return ContentService
    .createTextOutput(JSON.stringify(info, null, 2))
    .setMimeType(ContentService.MimeType.JSON);
}

/**
 * Get the target sheet by name
 * 
 * @returns {Sheet|null} The target sheet or null if not found
 */
function getTargetSheet() {
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
    return spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
  } catch (error) {
    Logger.log('Error accessing sheet:', error);
    return null;
  }
}

/**
 * Transform raw sheet rows into objects using headers as keys
 * 
 * @param {Array} headers - Column headers
 * @param {Array} rows - Data rows
 * @returns {Array} Array of objects
 */
function transformRowsToObjects(headers, rows) {
  return rows.map(row => {
    const obj = {};
    headers.forEach((header, index) => {
      // Handle empty cells and various data types
      let value = row[index];
      
      // Convert various types appropriately
      if (value instanceof Date) {
        value = value.toISOString();
      } else if (value === null || value === undefined) {
        value = '';
      } else {
        value = value.toString();
      }
      
      obj[header] = value;
    });
    return obj;
  });
}

/**
 * Apply query parameter filters to the data
 * 
 * @param {Array} data - Array of objects to filter
 * @param {Object} params - Query parameters
 * @returns {Array} Filtered data
 */
function applyFilters(data, params) {
  if (!params || Object.keys(params).length === 0) {
    return data;
  }

  return data.filter(row => {
    return Object.keys(params).every(key => {
      // Skip pagination parameters
      if (['limit', 'offset', 'page'].includes(key.toLowerCase())) {
        return true;
      }
      
      const rowValue = row[key];
      const filterValue = params[key];
      
      if (rowValue === undefined || rowValue === null) {
        return false;
      }
      
      // Case-insensitive string matching with partial matches
      const rowStr = rowValue.toString().toLowerCase();
      const filterStr = filterValue.toString().toLowerCase();
      
      // Support different matching modes
      if (filterStr.startsWith('=')) {
        // Exact match
        return rowStr === filterStr.substring(1);
      } else if (filterStr.startsWith('>')) {
        // Greater than (for numbers/dates)
        return parseFloat(rowValue) > parseFloat(filterStr.substring(1));
      } else if (filterStr.startsWith('<')) {
        // Less than (for numbers/dates)
        return parseFloat(rowValue) < parseFloat(filterStr.substring(1));
      } else {
        // Default: contains (case-insensitive)
        return rowStr.includes(filterStr);
      }
    });
  });
}

/**
 * Apply pagination to the data
 * 
 * @param {Array} data - Array of data to paginate
 * @param {Object} params - Query parameters
 * @returns {Object} Paginated result with metadata
 */
function applyPagination(data, params = {}) {
  const total = data.length;
  
  // Support both limit/offset and page/per_page patterns
  let limit = parseInt(params.limit || params.per_page) || total;
  let offset = parseInt(params.offset) || 0;
  
  // Handle page-based pagination
  if (params.page) {
    const page = parseInt(params.page) || 1;
    const perPage = parseInt(params.per_page || params.limit) || 50;
    limit = perPage;
    offset = (page - 1) * perPage;
  }
  
  // Ensure reasonable limits
  limit = Math.min(limit, 1000); // Max 1000 items per request
  offset = Math.max(offset, 0);   // No negative offsets
  
  const hasMore = offset + limit < total;
  const paginatedData = data.slice(offset, offset + limit);
  
  const result = {
    data: paginatedData,
    total: total
  };
  
  // Add pagination metadata if pagination was applied
  if (offset > 0 || limit < total) {
    result.pagination = {
      total: total,
      limit: limit,
      offset: offset,
      hasMore: hasMore,
      page: params.page ? parseInt(params.page) : Math.floor(offset / limit) + 1,
      totalPages: Math.ceil(total / limit)
    };
  }
  
  return result;
}

/**
 * Create a success response
 * 
 * @param {*} data - Response data
 * @param {Object} metadata - Additional metadata
 * @returns {TextOutput} JSON response
 */
function createSuccessResponse(data, metadata = {}) {
  const response = {
    success: true,
    ...metadata
  };
  
  // If data is not already in the metadata, add it
  if (!metadata.data) {
    response.data = data;
  }
  
  return ContentService
    .createTextOutput(JSON.stringify(response))
    .setMimeType(ContentService.MimeType.JSON);
}

/**
 * Create an error response
 * 
 * @param {string} message - Error message
 * @param {number} code - HTTP status code
 * @returns {TextOutput} JSON error response
 */
function createErrorResponse(message, code = 500) {
  const response = {
    success: false,
    error: {
      message: message,
      code: code,
      timestamp: new Date().toISOString()
    },
    api: {
      version: CONFIG.VERSION,
      generatedBy: CONFIG.GENERATED_BY
    }
  };
  
  return ContentService
    .createTextOutput(JSON.stringify(response))
    .setMimeType(ContentService.MimeType.JSON);
}

/**
 * Administrative function to get API configuration
 * Can be called manually from the Apps Script editor
 * 
 * @returns {Object} Current configuration
 */
function getAPIConfig() {
  return CONFIG;
}

/**
 * Administrative function to test the API
 * Can be called manually from the Apps Script editor
 * 
 * @returns {Object} Test result
 */
function testAPI() {
  try {
    const testEvent = { parameter: {} };
    const response = doGet(testEvent);
    const content = response.getContent();
    return JSON.parse(content);
  } catch (error) {
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Get basic sheet statistics
 * Can be called manually from the Apps Script editor
 * 
 * @returns {Object} Sheet statistics
 */
function getSheetStats() {
  try {
    const sheet = getTargetSheet();
    if (!sheet) {
      return { error: 'Sheet not found' };
    }
    
    const range = sheet.getDataRange();
    const values = range.getValues();
    
    return {
      sheetName: CONFIG.SHEET_NAME,
      spreadsheetTitle: CONFIG.SPREADSHEET_TITLE,
      totalRows: values.length,
      totalColumns: values.length > 0 ? values[0].length : 0,
      dataRows: Math.max(0, values.length - 1), // Exclude header
      headers: values.length > 0 ? values[0] : [],
      lastModified: sheet.getLastUpdated(),
      range: range.getA1Notation()
    };
  } catch (error) {
    return {
      error: error.toString()
    };
  }
} 